#!/usr/bin/env python3

# Standard imports
import time
import datetime
import argparse
import signal
import sys
import os
import numpy as np

# Bluerobotics ping library import, inform the user if they don't have it
try:
    from brping import Ping1D
except ModuleNotFoundError:
    print("bluerobotics-ping-sonar-to-csv: brping module not found, run 'pip3 install --user bluerobotics-ping'", file=sys.stderr)
    exit(1)


# todo
# - watchdog
#   - --verbose: output debug messages to stderr
#   - desired directory structure (specify in systemd): something like:
#         desirable
#             my-log-dir/20200101T000000/ping-sonar/20200101T00001.bin ...
#             my-log-dir/20200101T000000/watchdog/20200101T000002.bin ...
#         minimum viable
#             my-log-dir/ping-sonar/20200101T00001.bin ...
#             my-log-dir/watchdog/20200101T00002.bin ...


description_string = """BlueRobotics Ping sonar data acquisition utility.

By default, continuously requests a profile from the sonar, outputs to STDOUT or
saves to timestamped files in a given directory. Output can be ASCII csv format 
or binary.

Fields are written in the order in which they appear below. See 
https://docs.bluerobotics.com/ping-protocol/pingmessage-ping1d/#1300-profile
for details on the return fields for a profile.

Output fields:
    t: UTC timestamp in ISO format
    distance (m): calculated return distance for most recent range measurement
    confidence (%): confidence in the most recent range measurement
    transmit_duration (us): acoustic pulse length
    ping_number: pulse/measurement count since boot
    scan_start (m): the beginning of the scan region in mm from the transducer
    scan_length (m): the length of the scan region
    gain_setting: 0: 0.6, 1: 1.8, 2: 5.5, 3: 12.9, 4: 30.2, 5: 66.1, 6: 144
    profile_data: 200 return strength measurements taken at regular intervals across the scan region
"""

examples = """Examples
    view sonar data live
        bluerobotics-ping-sonar-to-csv | cut -d, -f2-8 --complement | image-accumulate --fields t,values --size=250,200 --output type=ub | cv-cat 'color-map=jet;resize=4;timestamp;view;null'
        
    view sonar log
        cat log.csv | cut -d, -f1-8 --complement | image-accumulate --size=250,200 --output type=ub | cv-cat 'color-map=jet;resize=4;view=-1;null'
"""

default_fields = "t,distance,confidence,transmit_duration,ping_number,scan_start,scan_length,gain_setting,profile_data"


# This is necessary to redirect the output from stdout when the ping object is initialised
class print_to_stderr():
    def __enter__(self):
        self._original_stdout = sys.stdout
        sys.stdout = sys.stderr

    def __exit__(self, exc_type, exc_val, exc_tb):
        sys.stdout = self._original_stdout


def signal_handler(sig, frame):
    global outfile
    outfile.write('\n')
    outfile.close()
    print('\n', file=sys.stderr)
    sys.exit(0)

    
# Function to print to stderr
def eprint(msg_str):
    timestamp = datetime.datetime.utcnow().isoformat().replace('-','').replace(':','')
    msg_str = timestamp + ": " + msg_str
    print( "bluerobotics-ping-sonar-to-csv: ", msg_str, file=sys.stderr)

        
# Formats the data from a scan and writes to STDOUT
def write_scan(data, profile_fields, args):
    global outfile
    if args.binary:
        b = b''
        for field in profile_fields:
            if field == "t":
                b += np.array([int(datetime.datetime.timestamp(datetime.datetime.utcnow()) * 1000000)], dtype=np.uint64).tobytes()
            elif field == "profile_data":
                b += data[field]
            elif field in [ "distance", "scan_start", "scan_length" ]:
                b += np.array([float( data[field] ) / 1000.0], dtype=np.float32).tobytes()
            elif field in [ "confidence", "transmit_duration" ]:
                b += np.array([data[field]], dtype=np.uint16).tobytes()
            else:
                b += np.array([data[field]], dtype=np.uint32).tobytes()

        if outfile is not None:
            outfile.write(b)
            outfile.flush()
        else:
            sys.stdout.buffer.write(b)
            if args.flush:
                sys.stdout.flush()
    else:
        s = []
        for field in profile_fields:
            if field == "t":
                s.append( datetime.datetime.utcnow().isoformat().replace('-','').replace(':','') )
            elif field == "profile_data":
                s.append( ','.join(map(str, data["profile_data"])) )
            elif field in [ "distance", "scan_start", "scan_length" ]:
                s.append( str( float( data[field] ) / 1000 ) )
            else:
                s.append( str(data[field]) )

        if outfile is not None:
            outfile.write(','.join(s) + '\n')
            outfile.flush()
        else:
            print(','.join(s))

            
# gets a timestamped file object to write to
def get_new_file(args):
    timestamp = datetime.datetime.utcnow().isoformat().replace('-','').replace(':','')
    if args.binary:
        return open(args.output_dir + "/" + timestamp + ".bin", "wb")
    else:
        return open(args.output_dir + "/" + timestamp + ".csv", "w")
    
# returns the first device in /dev with ttyUSB in the name
def guess_device():
    devices = os.listdir('/dev')
    for dev in devices:
        if dev.find('ttyUSB') != -1:
            return dev



    
 
def get_args():
    parser = argparse.ArgumentParser(description=description_string, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('--baudrate', action="store", type=int, default=115200, help="Ping device baudrate (default: 115200)")
    parser.add_argument('--binary', action="store_true", help="output in binary format")
    parser.add_argument('--consecutive-fail-limit', action="store", type=int, default=10, help="number of consecutive failures to collect data before trying to reconnect to device. Default: 10")
    parser.add_argument('--device', action="store", type=str, help="Ping device port, e.g. /dev/ttyUSB0. If not specified, will use first connected USB serial device.")
    parser.add_argument('--fields', default=default_fields, type=str, help="fields to output (default: all)")
    parser.add_argument('--flush', action="store_true", help="flush STDOUT every time a scan is received. Without this it can take a while before any output is observed")
    parser.add_argument('--output-dir', action="store", type=str, help="if specified, writes data to timestamped files in given directory rather than STDOUT")
    parser.add_argument('--output-fields', action="store_true", help="print all output fields to STDOUT and exit")
    parser.add_argument('--output-format', action="store_true", help="print binary output format to STDOUT and exit")
    parser.add_argument('--records-per-file', action="store", type=int, default=10000, help="number of records to write to file before rotating to a new file (default: 10000)")
    return parser.parse_args()







def main(args):

    if args.output_format:
        print( "t,f,uw,uw,ui,f,f,ui,200ub" )
        exit(0)

    if args.output_fields:
        print(default_fields)
        exit(0)

    # Handle SIGINT from ctrl+c
    signal.signal(signal.SIGINT, signal_handler)

    # Open the initial outfile to write to, if specified
    global outfile
    if args.output_dir is not None:
        outfile = get_new_file(args)
    else:
        outfile = None

    if args.device is None:
        device = guess_device()
        if device is None:
            eprint("device not specified and no devices could be found")
            exit(1)
        else:
            device = "/dev/" + device
            eprint( "device not specified, using " + device )
            args.device = device

    # Initialise a Ping object
    with print_to_stderr():
        myPing = Ping1D()
        myPing.connect_serial(args.device, args.baudrate)
    if not myPing.initialize():
        eprint("failed to initialize Ping1D!")
        exit(1)

    # Set the ping interval at 10ms
    if not myPing.set_ping_interval(10):
        eprint("failed to set ping interval")

            
    # Variable to store consecutive attempts at getting data before trying to reconnect 
    consecutive_fails = 0

    # Get fields to write
    profile_fields = args.fields.split(',')

    # counter for number of records per file
    count = 0
    
    # Get profile measurements continuously
    while True:
        data = myPing.get_profile()
        if data:
            count += 1
            if count > args.records_per_file and args.output_dir is not None:
                outfile.close()
                outfile = get_new_file(args)
                count = 0
            
            # This if block handles the cleanup after a disconnection event
            if consecutive_fails != 0:
                consecutive_fails = 0
                # If we have recovered from a disconnection or other error, we must again set
                # the ping interval, as it may have been reset
                if not myPing.set_ping_interval(10):
                    eprint("failed to set ping interval")
                    
            # Write the data to stdout or file, as appropriate        
            write_scan(data, profile_fields, args)
            
        else:
            consecutive_fails += 1
            eprint("warning: failed to get distance data")
            time.sleep(1.0)
            if consecutive_fails > args.consecutive_fail_limit:
                eprint("\nit seems like the Ping is not responding, attempting to reconnect...")
                if not ping_device.initialize():
                    eprint("failed to initialize Ping1D!")
                    exit(1)

    return 0

if __name__ == '__main__':
    sys.exit(main(get_args()))

