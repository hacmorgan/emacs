-- import data.char(tolower)
-- import data.list(group,sort,sortby)

-- tocartesian :: (double, double) -> (double, double)
-- tocartesian (r, theta) = (x, y)
--   where x = r * cos theta
--         y = r * sin theta



-- {- this stuff -}
-- twice :: (a -> a) -> (a -> a)
-- twice f a = f (f a)

-- double :: int -> int
-- double x = x * 2
-- {-
-- the function double can also be written as:
-- double = \x -> x * 2
-- -}


-- {-
--   twice twice double 3
--   == (twice twice double) 3
--   == (twice (twice double)) 3
--   == (twice quadruple) 3
--   == quadruple quadruple 3
-- -}

-- quadruple :: int -> int
-- quadruple = twice double


-- breakintowords :: string -> [string]
-- breakintowords = words --see words function in the standard library  (hoogle)

-- {-
-- recall that string is a list of chars
-- tolower :: char -> char
-- so we map tolower to all the chars in a string
-- and map that to all the strings in our list
-- -}
-- convertintolowercase :: [string] -> [string]
-- convertintolowercase = map (map tolower)

-- sortwords :: [string] -> [string]
-- sortwords = sort

-- type run = (int, string)
-- countadjacentruns :: [string] -> [run]
-- countadjacentruns  = convertoruns . groupadjacentruns

-- groupadjacentruns :: [string] -> [[string]]
-- groupadjacentruns = group

-- convertoruns :: [[string]] -> [run]
-- convertoruns = map (\ls -> (length ls, head ls) )
-- --convertoruns ls = (map ls -> (length ls, head ls) )

-- sortbyrunsize :: [run] -> [run]
-- sortbyrunsize = sortby (\(l1, w1) (l2, w2) -> compare l2 l1)

-- takefirstn :: int -> [run] -> [run]
-- takefirstn = take

-- generatereport :: [run] -> string
-- generatereport = unlines . map ( \(l,w) -> w ++ ":" ++ show l )


-- {-
-- for the definition of mostcommonwords below, think:
-- "given an int n, i will return a function from string to string"
-- which can also be written as:
-- mostcommonwords :: int -> (string -> string)
-- -}
-- mostcommonwords :: int -> string -> string
-- mostcommonwords n =
--   ( generatereport
--   . takefirstn n
--   . sortbyrunsize
--   . countadjacentruns
--   . sortwords
--   . convertintolowercase
--   . breakintowords) 


-- --making our own map function!
-- mymap :: (a -> b) -> ([a] -> [b])
-- mymap f [] = []
-- mymap f (x:xs) = f x : (mymap f xs)

-- foldr' :: (a -> b -> b) -> b -> [a] -> b
-- foldr' f z [] = z
-- foldr' f z (x:xs) = x `f` (foldr' f z xs)

-- sum' = foldr' (+) 0
-- concat' = foldr' (++) []

-- filter' :: (a -> bool) -> [a] -> [a]
-- filter' p [] = []
-- --filter' p (x:xs) = if p x then x : filter' p xs
-- --                          else filter' p xs
-- filter' p (x:xs)





{-
Some experimenting for the quiz
-}


addOne :: Int -> Int
addOne x = x + 1

dubbl :: [Int] -> [Int]
dubbl = \xs -> map addOne xs


{--- | p x       = x : filter' p xs
-- | otherwise = filter' p xs-}
